

## Synthèse structure actuelle

- DronesContext : source WebSocket + historique JSON, traitements légers.
- App.tsx : orchestration principale, gestion sélection, fusion + filtres.
- Hooks métier (useLiveTraces, useLocalHistory, etc.) : logiques liées au traitement des vols, traces, pagination.
- Services API / ancrage : appels réseaux + traitement spécifique.
- Composants UI : affichage, interaction visuelle, gestion modale, pagination.
- Config & utils : paramètres globaux, formatage, icônes.

 Revue composants UI

- Passer uniquement les données déjà traitées et filtrées aux composants TablesLayout, MapLayout, etc.
- Supprimer toute logique métier ou filtrage dans ces composants.
- Garder uniquement responsabilité affichage, interactions UI pures.


les composententes "anchored" était prévu à l'origine pour vérifier dans une blockchain api les vol archivées 
(le backend s'occupe des requets et fournit les résulatt) et compare aux historiques locaux. mais comme le backend 
aura lui meme l'historique et l'accès à la blockchain api, faut il toujour effectuer la comparaison des donées dans 
le front ? au final le but est d'empecher de pouvoir ancrer dans la blockchain un vol déjà pésent dans la blockchain.
les composententes "anchored" était prévu à l'origine pour vérifier dans une blockchain api les vol archivées 
(le backend s'occupe des requets et fournit les résulatt) et compare aux historiques locaux. mais comme le backend aura 
lui meme l'historique et l'accès à la blockchain api, faut il toujour effectuer la comparaison des donées dans le front ? 
au final le but est d'empecher de pouvoir ancrer dans la blockchain un vol déjà pésent dans la blockchain


Clearspace est un projet d'application web qui permet de visualiser les détection de drone et de les ancrer dans une blockchain.
Pour cela le projet est composé d'un backend qui va interroger la machine de détection qui elle renvoi le donnée des drones détecté en vol.
Le frontend reçoit les informations données par le backend et peut également permettre d'aficher un historique des vols enregistré dans un fichier json (coté backend) et permet de lancer un ancrage d'un vol, en donnant une description ainsi qu'en sélectionnant la zone de la carte à mettre en capture d'écran accompagnant le json d'information du vol.


Optimisation des dépendances des hooks
Veiller à ce que les dépendances des hooks (useCallback, useEffect) soient exhaustives et ne provoquent pas de 
re-rendus/invocations inutiles.
Exemple : getTraceForFlight dépend uniquement de liveTraces — si une fonction externe comme setSelected est utilisée, 
s'assurer qu'elle est stable ou listée.

Gestion d’erreurs centralisée améliorée
Le hook useErrorManager pourrait filtrer les doublons d'erreurs identiques pour éviter la répétition de messages.
Ajouter des priorités et gestion des erreurs critiques vs warnings.
++couleurs
Sauvegarder éventuellement l’historique d’erreurs pour debug. (bouton discret sous live détail)

Chargement asynchrone et états de chargement
Ajouter des indicateurs visuels dans l’UI pour signaler le chargement des données (live ou historiques).
Gérer plus finement les erreurs réseau/display utilisateur avec messages plus explicites.

Typage renforcé
Remplacer les casts (flight as any) par un typage le plus précis possible pour éviter les erreurs au runtime.
Typage strict des traces (gestion des deux formats LatLng et LatLngTimestamp).
Ajouter des validations dans les hooks/utilitaires pour détecter les anomalies de format.

Séparation des préoccupations
Déléguer la construction du JSON d’export (exportSelectedAsAnchorJson) dans un fichier/service dédié (ex : anchorExportService.ts).
Idem pour la fonction getTraceForFlight déplacée dans un utilitaire.

Amélioration des performances
Envisager la mémorisation en profondeur si le filtering devient lourd.
Utiliser des librairies dédiées pour la comparaison d’objets complexes (ex : lodash.isequal) plutôt que JSON stringify.
Accessibilité et ergonomie UI
Vérifier que la navigation clavier et l’accessibilité ARIA sont bien gérées pour les boutons et notifications.
Ajouter des messages de confirmation visuelle lors des actions sensibles (ex : export JSON).

Tests unitaires et d’intégration
Ajouter des tests des hooks métier et composants cruciaux pour améliorer la fiabilité et faciliter les évolutions.


L'objectif est le suivant, le backend envoie la liste des noms de fichiers d'historique.
Ensuite le front end récupère la liste afin d'envoyer la requête de récupération des données du fichier le plus récent.
ainsi le frontend récupère la listedes vols enregistrés et affiche dans le tableau.
coté backend, dès qu'un vol n'est plus détecté pendant plus d'un certaintemp, il est passé en "type" = local.
ensuite il envoie l'information "refresh au frontend" accompagné du nom du dossier concerné.
cela permet au frontend de savoir quand mettre à jour sa liste si le fichier modifié est le fichier actuellement consulté.



Projet Clearspace – Gestion des vols de drones et historique
Contexte général
Le projet Clearspace est une application permettant la détection, le suivi et l'archivage des vols de drones.
Le système comprend deux parties centrales :
un backend dédié à la collecte et au stockage des données,
un frontend pour la visualisation en temps réel et la consultation des historiques.
Fonctionnement du backend
Le backend est développé en Node.js et s'appuie sur plusieurs modules orchestrés :
Collecte et traitement des vols :
Les vols sont reçus en direct avec un identifiant unique (id), un type (live par défaut), une trace GPS, et d'autres métadonnées.
Gestion du timeout des vols :
Un mécanisme de temporisation détecte les vols inactifs.
Dès que le drone n'est plus détecté depuis un délai configuré (inactiveTimeout), il est « limogé » de l'état live pour être archivé en local.
Archivage en fichiers JSON :
Les vols (live & archivés) sont stockés dans des fichiers JSON organisés par période hebdomadaire (ex : history-YYYY-MM-DD_to_YYYY-MM-DD.json).
Le backend maintient un cache en mémoire de ces fichiers via historyCache.
Mise à jour & fusion des données :
Lorsqu'un vol évolue, il est soit ajouté, soit fusionné aux données archivées avec des règles précises sur la gestion des traces.
Notification des clients :
À chaque modification d'un fichier historique, notamment lorsqu'un vol devient local (archivé),
le backend notifie tous les clients connectés via une notification WebSocket de type refresh avec le nom du fichier modifié.
Fonctionnement du frontend
Le frontend, construit avec React, s'organise autour de plusieurs couches :
Context DronesContext :
Gère la connexion WebSocket, reçoit les mises à jour des vols en direct, la liste des fichiers d'historique disponibles,
et les notifications refresh.
Hook métier useAppLogic :
Coordonne les sources de données
Réception temps réel via WebSocket (vols live),
Chargement & pagination des historiques via fetch HTTP des fichiers JSON,
Gestion de la sélection, détails, export JSON, et intégration de la géolocalisation pour les traces.
Hook useLocalHistory :
Chargement du fichier historique courant, rafraîchissement déclenché sur réception de notification, pagination.
Affichage :
HistorySelector (à intégrer) :
permet à l'utilisateur de choisir le fichier historique à consulter.
TablesLayout :
affiche les vols live et archivés dans des tableaux, avec filtres basés sur le champ type.
MapLayout :
visualisation spatiale des traces des vols.

Problème actuel
Contexte :
Les vols passent bien du statut live à local côté backend à l’expiration du timeout.
Le backend modifie la donnée, met à jour le fichier JSON et envoie une notification WebSocket refresh indiquant le nom du fichier modifié.
Problème :
Le frontend reçoit bien ces notifications, mais la mise à jour du fichier d'historique n'a pas l'air de se faire car aucun nouveau vol affiché, sauf quand on refresh la page.
De plus on remarque une reception du refresh très fréqunte alors qu'aucun vol n'est passé de live à local dnas le backend.
Analyse possible :
Le backend peut générer plusieurs notifications refresh très rapprochées, peut-être suite à des modifications successives de vols et un appel mal placé du notify avec resh ou mauvaise conditions d'activation.
Le frontend reçoit bien refresh mais ne le gère pas correctement. il faut revoir la chaine de refresh.


autreeeee
une fois que le drone est délectionneé, mettre en surbrillance, ne pas mettre à jour la position de vue à chauqe mise a jour 
ajuster zone Details
ajuster backend live persistant
ajuter historique d'erreurs
ajuter Detection table et autres tables les memee ?
ajuster fin de vol = ignorer (ou garder jusqua validation)
ajutser les confis et constants
_type à vérifier
