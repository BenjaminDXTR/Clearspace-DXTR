

## Synthèse structure actuelle

- DronesContext : source WebSocket + historique JSON, traitements légers.
- App.tsx : orchestration principale, gestion sélection, fusion + filtres.
- Hooks métier (useLiveTraces, useLocalHistory, etc.) : logiques liées au traitement des vols, traces, pagination.
- Services API / ancrage : appels réseaux + traitement spécifique.
- Composants UI : affichage, interaction visuelle, gestion modale, pagination.
- Config & utils : paramètres globaux, formatage, icônes.

 Revue composants UI

- Passer uniquement les données déjà traitées et filtrées aux composants TablesLayout, MapLayout, etc.
- Supprimer toute logique métier ou filtrage dans ces composants.
- Garder uniquement responsabilité affichage, interactions UI pures.


voici l'objectif d'ancrage actuel:
l'objectif est le suivant, gérer la fonctionnalité principale du frontend : la création des fichiers d'ancrage.
Coté frontend, les composantes Anchor, useAnchorModal etc... doivent se charger de permettre à l'utilisateur, une fois un vol sélectionné dans l'historique,
de choisi d'ancrer, c'est à dire créer les fichier qui seront envoyés dans la blockchain.
l'utilisateur pourra visualisé le json qui sera enregistré (le json contiens des champs définit spécialement pour l'ancrage afin de correspondre à la frome
attendue dans l'api blockchain) et pour ajouter un commentaire.
coté carte,  elle est positionnée à l'ouverture sur la zone du vol (comme sur la carte principale ) il pourra visualiser le tracé et déplacer la carte pour
choisir quelle partie sera passé au moment de la capture. 
Lors de la validation de l'ancrage, un dossier nommé de façon cohérente (date , id etc...) est créé et contiens le json d'ancrage, et un dossier zippé,
ce dossier zippé contient toutes les preuves, images capturées mais aussi la liste complète des trace avec la date de départ et leur valeur de temps associé.
pour la partie backend, une fois un enregistrement validé et le dossier créé, le front enverra le nom du dossier par une route afin que le backend gère
une liste des dossier à ancrer une fois une connexion internet disponible et connexion à la blockchain établie.



Clearspace est un projet d'application web qui permet de visualiser les détection de drone et de les ancrer dans une blockchain.
Pour cela le projet est composé d'un backend qui va interroger la machine de détection qui elle renvoi le donnée des drones détecté en vol.
Le frontend reçoit les informations données par le backend et peut également permettre d'aficher un historique des vols enregistré dans un fichier json (coté backend) et permet de lancer un ancrage d'un vol, en donnant une description ainsi qu'en sélectionnant la zone de la carte à mettre en capture d'écran accompagnant le json d'information du vol.


Optimisation des dépendances des hooks
Veiller à ce que les dépendances des hooks (useCallback, useEffect) soient exhaustives et ne provoquent pas de 
re-rendus/invocations inutiles.
Exemple : getTraceForFlight dépend uniquement de liveTraces — si une fonction externe comme setSelected est utilisée, 
s'assurer qu'elle est stable ou listée.

Gestion d’erreurs centralisée améliorée
Le hook useErrorManager pourrait filtrer les doublons d'erreurs identiques pour éviter la répétition de messages.
Ajouter des priorités et gestion des erreurs critiques vs warnings.
++couleurs
Sauvegarder éventuellement l’historique d’erreurs pour debug. (bouton discret sous live détail)

Chargement asynchrone et états de chargement
Ajouter des indicateurs visuels dans l’UI pour signaler le chargement des données (live ou historiques).
Gérer plus finement les erreurs réseau/display utilisateur avec messages plus explicites.

Typage renforcé
Remplacer les casts (flight as any) par un typage le plus précis possible pour éviter les erreurs au runtime.
Typage strict des traces (gestion des deux formats LatLng et LatLngTimestamp).
Ajouter des validations dans les hooks/utilitaires pour détecter les anomalies de format.

Séparation des préoccupations
Déléguer la construction du JSON d’export (exportSelectedAsAnchorJson) dans un fichier/service dédié (ex : anchorExportService.ts).
Idem pour la fonction getTraceForFlight déplacée dans un utilitaire.

Amélioration des performances
Envisager la mémorisation en profondeur si le filtering devient lourd.
Utiliser des librairies dédiées pour la comparaison d’objets complexes (ex : lodash.isequal) plutôt que JSON stringify.
Accessibilité et ergonomie UI
Vérifier que la navigation clavier et l’accessibilité ARIA sont bien gérées pour les boutons et notifications.
Ajouter des messages de confirmation visuelle lors des actions sensibles (ex : export JSON).

Tests unitaires et d’intégration
Ajouter des tests des hooks métier et composants cruciaux pour améliorer la fiabilité et faciliter les évolutions.


L'objectif est le suivant, le backend envoie la liste des noms de fichiers d'historique.
Ensuite le front end récupère la liste afin d'envoyer la requête de récupération des données du fichier le plus récent.
ainsi le frontend récupère la listedes vols enregistrés et affiche dans le tableau.
coté backend, dès qu'un vol n'est plus détecté pendant plus d'un certaintemp, il est passé en "type" = local.
ensuite il envoie l'information "refresh au frontend" accompagné du nom du dossier concerné.
cela permet au frontend de savoir quand mettre à jour sa liste si le fichier modifié est le fichier actuellement consulté.



Projet Clearspace – Gestion des vols de drones et historique
Contexte général
Le projet Clearspace est une application permettant la détection, le suivi et l'archivage des vols de drones.
Le système comprend deux parties centrales :
un backend dédié à la collecte et au stockage des données,
un frontend pour la visualisation en temps réel et la consultation des historiques.
Fonctionnement du backend
Le backend est développé en Node.js et s'appuie sur plusieurs modules orchestrés :
Collecte et traitement des vols :
Les vols sont reçus en direct avec un identifiant unique (id), un type (live par défaut), une trace GPS, et d'autres métadonnées.
Gestion du timeout des vols :
Un mécanisme de temporisation détecte les vols inactifs.
Dès que le drone n'est plus détecté depuis un délai configuré (inactiveTimeout), il est « limogé » de l'état live pour être archivé en local.
Archivage en fichiers JSON :
Les vols (live & archivés) sont stockés dans des fichiers JSON organisés par période hebdomadaire (ex : history-YYYY-MM-DD_to_YYYY-MM-DD.json).
Le backend maintient un cache en mémoire de ces fichiers via historyCache.
Mise à jour & fusion des données :
Lorsqu'un vol évolue, il est soit ajouté, soit fusionné aux données archivées avec des règles précises sur la gestion des traces.
Notification des clients :
À chaque modification d'un fichier historique, notamment lorsqu'un vol devient local (archivé),
le backend notifie tous les clients connectés via une notification WebSocket de type refresh avec le nom du fichier modifié.
Fonctionnement du frontend
Le frontend, construit avec React, s'organise autour de plusieurs couches :
Context DronesContext :
Gère la connexion WebSocket, reçoit les mises à jour des vols en direct, la liste des fichiers d'historique disponibles,
et les notifications refresh.
Hook métier useAppLogic :
Coordonne les sources de données
Réception temps réel via WebSocket (vols live),
Chargement & pagination des historiques via fetch HTTP des fichiers JSON,
Gestion de la sélection, détails, export JSON, et intégration de la géolocalisation pour les traces.
Hook useLocalHistory :
Chargement du fichier historique courant, rafraîchissement déclenché sur réception de notification, pagination.
Affichage :
HistorySelector (à intégrer) :
permet à l'utilisateur de choisir le fichier historique à consulter.
TablesLayout :
affiche les vols live et archivés dans des tableaux, avec filtres basés sur le champ type.
MapLayout :
visualisation spatiale des traces des vols.

autreeeee
une fois que le drone est selectionneé, mettre en surbrillance, ne pas mettre à jour la position de vue à chauqe mise a jour 
ajuster zone Details
ajuter historique d'erreurs
ajuter Detection table et autres tables les memee ?
ajuster fin de vol = ignorer (ou garder jusqua validation)
ajutser les config et constants
ajuster les noms des fichiers
_type à vérifier

backend:
1. Tests et couverture avec logs améliorés

    Effectuer des tests fonctionnels complets (unitaires et intégration) pour vérifier le comportement des modules critiques (poller, flightsManager, historyCache).

    Utiliser les logs enrichis pour identifier toute incohérence, lenteur, ou erreurs en conditions réelles/charge.

2. Optimisation des performances

    Regrouper/optimiser les flushs disques pour éviter surcharge IO, notamment dans poller et gestion cache.

    Évaluer un mécanisme limiteur/pagination dans la gestion des traces pour éviter croissance mémoire et taille de fichiers trop grandes.

3. Sécurisation backend

    Auditer middleware pour protection contre injection, requêtes malformées, etc.

    Envisager un contrôle d’accès (authentification, authorization) sur les API et WebSocket.

4. Robustesse résilience

    Ajouter mécanismes de retry ou fallback dans la communication avec la source des données drone (GraphQL).

    Optimiser gestion des erreurs réseau WebSocket pour éviter pertes de déconnexion.

5. Documentation & Monitoring

    Documenter clairement chaque module backend avec exemples d’usage attendus.

    Mettre en place monitoring/alerting sur erreurs backend critiques, performances, état du poller.

6. Déploiement & maintenance

    Préparer scripts/directions pour déploiement fiable (docker, CI/CD).

    Automatiser nettoyage périodique des vieux fichiers historiques.
