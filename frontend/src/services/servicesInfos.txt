Ces services font partie de la couche « d’accès aux fonctionnalités » du frontend.
Ils encapsulent des fonctions utilitaires spécifiques, accessibles à différents composants, pour :

    anchorService.ts → capturer, préparer et envoyer les preuves d’ancrage au backend.

    localHistoryService.ts → gérer l’historique local d’archives de vols via localStorage.

1️⃣ src/services/anchorService.ts
🎯 Rôle

Prépare et envoie au backend les données d’ancrage d’un vol, en générant une preuve image encapsulée dans un fichier ZIP.
📦 Fonctions principales
buildAnchorData(flight: Flight, description?: string): AnchorData

    But : Créer l’objet JSON à ancrer à partir des infos de vol.

    Champs inclus :

        altitude, created_time, distance, id, latitude, longitude, name.

        description passée depuis l’UI.

        anchored_at : timestamp ISO de la préparation.

    Important : la trace complète n’est pas incluse ici (elle est capturée en image séparément).

captureMapImage(mapDiv?: HTMLElement | null, scale?: number): Promise<Blob | null>

    But : Produire une capture PNG de la carte Leaflet.

    Options :

        mapDiv : élément DOM cible (sinon cherche .leaflet-container).

        scale haute résolution (défaut : 5 pour meilleure qualité).

    Retour : Blob PNG ou null si échec.

    Internals : utilise html2canvas avec useCORS et fond transparent.

generateImageZip(mapImageBlob: Blob): Promise<Blob>

    But : Créer un archive .zip contenant l’image capturée.

    Implémentation : via JSZip.

    Contenu : carte.png dans le ZIP.

    Retour : Blob du ZIP, prêt à l’envoi.

sendAnchorToBackend(anchorData: AnchorData, zipBlob: Blob): Promise<AnchorResponse>

    But : Uploader les métadonnées JSON + fichier ZIP vers le backend (/anchor).

    Format : multipart/form-data (FormData).

        champ JSON → "anchorData"

        champ fichier ZIP → "proofZip"

    Réponse attendue : { folder?: string, message?: string, ... } indiquant le dossier d’ancrage ou un message.

    Gestion d’erreurs : vérifie statut HTTP et retourne le JSON, sinon lève une Error.

📌 Points à retenir

    URL backend doit être centralisée dans utils/constants.ts (ANCHOR_URL).

    Le nom des champs (anchorData, proofZip) doit correspondre exactement à ce qui est attendu par le backend.

    Vérifier que le ZIP n’est pas vide avant envoi.

    Possibilité de personnaliser :

        le nom du fichier image dans le ZIP

        le nom du fichier ZIP

        le scale de capture

2️⃣ src/services/localHistoryService.ts
🎯 Rôle

Gère localement, dans le navigateur, la liste des vols archivés « en cache » pour consultation hors ligne.
📦 Constantes importantes

    LOCAL_STORAGE_KEY = "droneweb_history" → clé unique côté storage.

    MAX_HISTORY_LENGTH = 100 → taille maximale de l’historique conservé.

📦 Fonctions principales
getLocalHistory(): Flight[]

    But : Lire le contenu JSON sous LOCAL_STORAGE_KEY et le convertir en tableau de Flight.

    Vérification : filtre via isFlight (valide id et created_time comme string).

    Retour : tableau de vols valides ou vide si absence/données invalides.

addToLocalHistory(flight: Flight): void

    But : Ajouter un vol à l’historique si non présent.

    Précautions :

        Si (id, created_time) déjà présent → ignore.

        Ajoute en tête de liste (unshift).

        Coupe à MAX_HISTORY_LENGTH éléments.

    Sauvegarde : réécrit totalement la clé LOCAL_STORAGE_KEY au format JSON.

removeFromLocalHistory(id: string, created_time: string): void

    But : Supprimer un vol précis de l’historique.

    Mécanisme : filtre tous les vols dont (id, created_time) ne correspond pas.

clearLocalHistory(): void (ajout possible conseillé)

    But : Vider complètement l’historique local.

    Implémentation : localStorage.removeItem(LOCAL_STORAGE_KEY).

📌 Points à retenir

    Les fonctions sont déterministes → l’état en local est toujours cohérent.

    isFlight() est la garde de type pour éviter stockage de données incorrectes.

    Ajout/lecture sont synchrone (rapidité du localStorage).

    Les logs peuvent être conditionnés à process.env.NODE_ENV === "development" pour éviter la pollution console en prod.

    Limiter le nombre d’éléments protège contre :

        lenteur d’accès localStorage

        surcharge mémoire

        tailles de JSON excessives
        
📌 Conseil global :

    Toujours centraliser les URLs externes dans utils/constants.ts

    Prévoir un flag global DEBUG pour tous les services afin de contrôler les logs depuis une seule variable.

    Les services sont faciles à tester unitairement → idéal pour sécuriser les futures évolutions.
