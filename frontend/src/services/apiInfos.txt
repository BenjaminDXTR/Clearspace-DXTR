Ce fichier est la couche dâ€™accÃ¨s aux donnÃ©es du frontend, centralisant tous les appels HTTP et GraphQL vers le backend.
Il contient les fonctions qui :

    Interrogent lâ€™API GraphQL pour rÃ©cupÃ©rer les donnÃ©es live ou distantes.

    Communiquent avec les endpoints REST (/history, /anchor, /anchored) pour manipuler des fichiers ou des historiques locaux.

    Normalisent la gestion des erreurs avec handleApiError, pour toujours renvoyer un message clair exploitable cÃ´tÃ© UI.

ğŸ’¡ Toute requÃªte rÃ©seau passe par ici, ce qui permet une maintenance centralisÃ©e et lâ€™ajout futur de gestion globale (logs, retries, tokens...).
ğŸ“œ DÃ©tail des fonctions
handleApiError(context: string, error: unknown): never

    But : uniformiser le formatage et le logging des erreurs rÃ©seau.

    Principe : Logge lâ€™erreur en console avec le nom du contexte et lÃ¨ve une exception Error avec un message standardisÃ©.

    Ã€ retenir :

        On pourrait plus tard Ã©tendre pour capturer aussi les erreurs cÃ´tÃ© monitoring distant.

        Toujours inclure le nom de la fonction appelante dans context pour debug aisÃ©.

fetchLiveDrones(): Promise<Flight[]>

    But : RÃ©cupÃ©rer la liste des drones actifs en live via GraphQL.

    RequÃªte : Envoie un query complet qui rÃ©cupÃ¨re tous les champs nÃ©cessaires au frontend (trajectoire, Ã©tat, position, etc.).

    Retour : Un tableau typÃ© Flight[] (vide si rien).

    Cas dâ€™erreur : CÃ´tÃ© backend ou rÃ©seau â†’ passe par handleApiError.

    Notes :

        La requÃªte est longue mais exhaustive : mieux vaut lâ€™externaliser dans un fichier graphqlQueries.ts pour lisibilitÃ©.

fetchHistoricEvents(): Promise<Event[]>

    But : RÃ©cupÃ¨re les Ã©vÃ©nements historiques distants, paginÃ©s et triÃ©s par date descendante.

    Retour : Event[] (peut Ãªtre vide si pas dâ€™Ã©vÃ©nement).

    Notes :

        Comme pour les drones, passer la requÃªte dans un fichier dÃ©diÃ© aux queries amÃ©liorerait la maintenabilitÃ©.

fetchDroneTraces(from, to): Promise<any[]>

    But : RÃ©cupÃ©rer les tracÃ©s de drones sur une pÃ©riode donnÃ©e (timestamps ou sÃ©quences).

    Retour : Tableau dâ€™objets { id, binding_id, created_time, points }.

    Attention :

        Les champs points contiennent souvent du JSON stringifiÃ© â†’ Ã  parser au moment de lâ€™utilisation.

fetchLocalHistory(): Promise<Flight[]>

    But : Charger lâ€™historique local des vols depuis le backend.

    Type : REST GET sur HISTORY_URL (fichier JSON cÃ´tÃ© serveur).

    Notes :

        Ã‰chec rÃ©seau ou HTTP status != 200 â†’ lÃ¨ve une erreur via handleApiError.

postLocalHistoryFlight(flight: Flight): Promise<void>

    But : Ajoute un vol Ã  lâ€™historique local (archivage).

    Type : REST POST avec payload JSON.

    Cas dâ€™erreur : Renvoi non-OK â†’ throw.

fetchAnchoredFlights(): Promise<Flight[]>

    But : RÃ©cupÃ¨le la liste des vols dÃ©jÃ  ancrÃ©s en blockchain.

    Type : REST GET sur /anchored (dÃ©rivÃ© de ANCHOR_URL).

    Cas dâ€™erreur : LÃ¨ve une erreur si status HTTP non-200.

postAnchorData(anchorData: any, zipBlob: Blob): Promise<void>

    But : Envoie un zip de donnÃ©es dâ€™ancrage et les mÃ©tadonnÃ©es associÃ©es au backend.

    Type : FormData (multipart).

    Important :

        Le champ fichier doit sâ€™appeler "proofZip" pour correspondre au backend (anchor.js).

        Le champ "anchorData" contient un JSON stringifiÃ©.

    Cas dâ€™erreur : Non-OK â†’ throw.

âœ… Bonnes pratiques pour maintenir ce fichier

    Externaliser les requÃªtes GraphQL
    Mettre les query longues dans src/utils/graphqlQueries.ts â†’ les fonctions ici auraient juste :

ts
const data = await fetchGraphQL(DRONE_QUERY, GRAPHQL_URL);

Factoriser les fetch REST
CrÃ©er un helper apiFetch qui :

    gÃ¨re automatiquement JSON parsing

    check res.ok

    passe les erreurs Ã  handleApiError

Exemple :

ts
async function apiFetch<T>(url: string, options?: RequestInit): Promise<T> {
  const res = await fetch(url, options);
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
}

GÃ©rer les tokens/autorisations
Si un jour tu ajoutes de lâ€™authentification â†’ toutes les fonctions ici pourront hÃ©riter du mÃªme mÃ©canisme (headers, refresh tokenâ€¦).

Centraliser les types de retour
Toujours typer Promise<T> mÃªme si T est any[], pour documenter ce qui est attendu par les composants.

Logs en dev uniquement
Ne garder console.error / console.log que si process.env.NODE_ENV === "development".
